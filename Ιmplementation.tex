\chapter{Υλοποίηση}
Η μετάφραση των παραπάνω θεωρητικών εννοιών και αλγορίθμων σε λειτουργικά προγράμματα είναι βασικός στόχος της επιστήμης των υπολογιστών. Στην παρούσα εργασία, μετά την απόκτηση του θεωρητικού υποβάθρου σχετικά με τη χάραξη πολυγώνων και την κατανόηση των απαιτήσεων για τη μέγιστη λειτουργικότητα των αλγορίθμων ψηφιδόξυσης, επικεντρωνόμαστε στην υλοποίηση του προγράμματος χάραξης και απεικόνισης κυρτών πολυγώνων με τη χρήση της \textlatin{OpenGL}. Στο πλαίσιο αυτό, εξετάζουμε και εξηγούμε το δοθέντα κώδικα για χάραξη τριγώνων \textlatin{triangle1} και έπειτα ακολουθεί η ερμηνεία της γενίκευσης σε \textlatin{convex1} για πολύγωνα. Σε δεύτερο στάδιο, παρουσιάζουμε βασικές εντολές που χρησιμοποιήθηκαν για την καλύτερη απόδοση του προγράμματος και αναλύουμε την ενσωμάτωση του αλγορίθμου \textlatin{Scanline} στον κώδικά μας για την απεικόνιση των κυρτών πολυγώνων. 

\section{Η διαδικασία \textlatin{triangle1}}
Παρακάτω αναγράφεται η διαδικασία \textlatin{triangle1}, η οποία είναι σε μορφή ψευδοκώδικα και περιγράφει έναν αλγόριθμο χάραξης τριγώνου.

\selectlanguage{english}
\begin{verbatim}
void triangle1(Vertex v0, Vertex v1, Vertex v2, Colour c) {
    Line l0, l1, l2;
    float e0, e1, e2, e0t, e1t, e2t;
    // Υπολογισμός των συντελεστών ευθείας (a, b, c) από τις κορυφές
    mkline(v0, v1, &l0); mkline(v1, v2, &l1); mkline(v2, v0, &l2);
    // Υπολογισμός του περιβάλλοντος κυτίου του τριγώνου
    int bb_xmin = std::min(v0.x, std::min(v1.x, v2.x));
    int bb_xmax = std::max(v0.x, std::max(v1.x, v2.x));
    int bb_ymin = std::min(v0.y, std::min(v1.y, v2.y));
    int bb_ymax = std::max(v0.y, std::max(v1.y, v2.y));
    // Εκτίμηση των γραμμικών συναρτήσεων στο σημείο (bb_xmin, bb_ymin)
    e0 = l0.a * bb_xmin + l0.b * bb_ymin + l0.c;
    e1 = l1.a * bb_xmin + l1.b * bb_ymin + l1.c;
    e2 = l2.a * bb_xmin + l2.b * bb_ymin + l2.c;
    for (int y = bb_ymin; y <= bb_ymax; y++) {
        e0t = e0; e1t = e1; e2t = e2;
        for (int x = bb_xmin; x <= bb_xmax; x++) {
            if (sign(e0) == sign(e1) == sign(e2)) {
                setPixel(x, y, c);
            }
            e0 = e0 + l0.a;
            e1 = e1 + l1.a;
            e2 = e2 + l2.a;
        }
        e0 = e0t + l0.b;
        e1 = e1t + l1.b;
        e2 = e2t + l2.b;
    }
}
\end{verbatim} 
\par
Η συνάρτηση παίρνει τρεις κορυφές ενός τριγώνου $(v0,v1,v2)$ και ένα χρώμα $c$ ως είσοδο. Η αναπαράσταση των ευθειών που σχηματίζονται από τις τρεις ακμές του τριγώνου γίνονται με βάση τη δομή δεδομένων \textlatin{line}. Υπολογίζεται το περιβάλλον κυτίο \textlatin{bounding box} του τριγώνου, δηλαδή το ελάχιστο και το μέγιστο $x$ και $y$ που καλύπτονται από το τρίγωνο. Ο κώδικας εκτελεί μια επανάληψη για κάθε γραμμή $y$ από το ελάχιστο ως το μέγιστο $y$ του περιβάλλοντος κυτίου. Σε αυτήν την επανάληψη, υπολογίζονται οι γραμμικές συναρτήσεις $(e0,e1,e2)$ για το σημείο $(bb_xmin, y)$, δηλαδή για κάθε στήλη $x$ από το ελάχιστο ως το μέγιστο $x$ του περιβάλλοντος κυτίου. 
\par
Στην εσωτερική επανάληψη για κάθε στήλη $x$ από το ελάχιστο ως το μέγιστο $x$ του περιβάλλοντος κυτίιου, γίνεται έλεγχος για το αν οι τιμές $(e0,e1,e2)$ έχουν το ίδιο πρόσημο. Αυτό υποδηλώνει ότι το σημείο $(x,y)$ είναι εντός του τριγώνου. Σε αυτήν την περίπτωση, η συνάρτηση $setPixel(x,y)$ καλείται για να χρωματίσει το σημείο $(x,y)$ με το καθορισμένο χρώμα $c$. 

\section{Η διαδικασία \textlatin{convex1}} 

Η διαδικασία χάραξης τριγώνων μπορεί αποτελεσματικά να γενικευθεί σε μια διαδικασία χάραξης κυρτών πολυγώνων. Παρακάτω παρουσιάζεται συνοπτικά η διαδικασία \textlatin{convex1}. Αρχικά ο κώδικας της συνάρτησης ελέγχει τον αριθμό των κορυφών του πολυγώνου και την κυρτότητα. Αν ο αριθμός είναι μικρότερος από τρεις ή το πολύγωνο δεν είναι κυρτό, η συνάρτηση τερματίζει δίχως να γίνει χάραξη. Στη συνέχεια, η συνάρτηση υπολογίζει τις ευθείες που αντιπροσωπεύουν τις πλευρές του πολυγώνου, καθώς και μια αρχική εκτίμηση για κάθε κορυφή του πολυγώνου. Αυτό επιτυγχάνεται με τη συνάρτηση \textlatin{mkline}, η οποία υπολογίζει τους συντελεστές της ευθείας που διέρχεται από δύο κορυφές. Δημιουργείται ένα διάνυσμα \textlatin{lines} για τις πλευρές. Οι αρχικές εκτιμήσεις περιέχονται στο διάνυσμα $es$. 'Επειτα, υπολογίζεται το περίβλημα του πολυγώνου, δηλαδή οι ελάχιστες και μέγιστες τιμές $x$ και $y$ ανάμεσα στις κορυφές. Αυτό το βήμα είναι απαραίτητο για τον περιορισμό της επανάληψης του αλγορίθμου της \textlatin{Scanline} στην περιοχή που περιβάλλει το πολύγωνο. 
\par
Με την εφαρμογή του αλγορίθμου, επιλέγεται κάθε γραμμή από το ελάχιστο $y$ ως το μέγιστο $y$ του περιβλήματος, ενώ ταυτόχρονα γίνεται έλεγχος της διέλευσης των γραμμών. Για να καθοριστεί εάν η κάθε γραμμή διασχίζει το πολύγωνο, δηλαδή για το εάν ένα σημείο βρίσκεται εντός ή εκτός του πολυγώνου, ο αλγόριθμος χρησιμοποιεί τη μέθοδο περιστροφής \textlatin{(winding number)}, καταμετρώντας τον αριθμό των περιστροφών που απαιτούνται για να διασχίσει το σημέιο κατά μήκος του πολυγώνου. Σε κάθε γραμμή, ο κώδικας ελέγχει αν η \textlatin{scanline} τέμνει τις πλευρές του πολυγώνου και υπολογίζει τον αριθμό των τεμνόμενων πλευρών. Αν το αποτέλεσμα είναι περιττό, τότε το σημείο ανήκει στο εσωτερικό του πολυγώνου και γίνεται η χάραξη του εικονοστοιχείου με το καθορισμένο χρώμα.   
\par
Με αυτόν τον τρόπο η παραγόμενη από το αρχέγονο τρίγωνο και τη συνάρτηση \textlatin{triangle1}, \textlatin{convex1} συνάρτηση, υλοποιεί τη χάραξη (ψηφιδόξυση) ενός κυρτού πολυγώνου με τη χρήση του αλγορίθμου \textlatin{Scanline}.  

\section{Υλοποίηση σε \textlatin{OpenGL}}

Η εργασία υλοποιήθηκε σε προγραμματιστικό περιβάλλον με τη χρήση \textlatin{C++/OpenGL} και χρησιμοποιήθηκε η βιβλιοθήκη \textlatin{GLUT} για τη δημιουργία γραφικού παραθύρου και την αλληλεπίδραση με το χρήστη. 

\begin{figure}
    \centering
    \includegraphics[width=0.35\textwidth]{images/convex1.png}
    \caption{Στιγμιότυπο του εκτελέσιμου προγράμματος}    
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.35\textwidth]{images/convex2.png}
    \caption{Στιγμιότυπο του εκτελέσιμου προγράμματος}    
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.35\textwidth]{images/convex3.png}
    \caption{Στιγμιότυπο του εκτελέσιμου προγράμματος}    
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{images/convex4.png}
    \caption{Στιγμιότυπο του εκτελέσιμου προγράμματος}    
\end{figure}
Από τα στιγμιότυπα είναι εύκολη η κατανόηση του προγράμματος. Όπως φαίνεται, το γέμισμα των κυρτών πολυγώνων γίνεται επιτυχώς με μπλε χρώμα για κάθε εσωτερικό εικονοστοιχείο. Τα μπλε πολύγωνα που αποτυπώνονται αποτελούν στιγμιότυπα από το ίδιο εκτελέσιμο, με το πολύγωνο στη \textlatin{Figure 2.3} να αποτελεί το τελευταίο εικονιζόμενο πριν ο χρήστης διακόψει το πρόγραμμα. Στην εικόνα της \textlatin{Figure 2.4} δεν υπάρχει γέμισμα, καθώς αποτελεί στιγμιότυπο από δοκιμή της υλοποίησης με χρήση του αλγορίθμου Jarvis, όπου μας ενδιέφερε ο υπολογισμός του περιβάλλοντος κυτίου \textlatin{(convex hull)}. Όμως σε αυτήν την περίπτωση μπορούσαμε επιτυχώς να δίνουμε στο χρήστη τη δυνατότητα να αντιληφθεί τη μορφολογία των πολυγώνων, αφού αν έδινε σημείο που σχημάτιζε εσωτερική γωνία μεγαλύτερη των $180^\circ$, το πρόγραμμα απέτρεπε το σχηματισμό μη κυρτού πολυγώνου, αλλά εμφάνιζε το εσωτερικό σημείο στην οθόνη με κόκκινο χρώμα. Ένας συνδυασμός των δεδομένων και των μεθόδων που χρησιμοποιήσαμε θα μπορούσε να μας δώσει τη δυνατότητα να επεξεργαστούμε τα πολύγωνα και να βελτιστοποιήσουμε προγράμματα με στόχο την ευρύτερη ανάπτυξη σε ένα φάσμα πεδίων που αξιοποιούν το σχεδιασμό των \textlatin{2D} και \textlatin{3D} πολυγώνων.
\par
Aναφορικά με τη δομή και τη σύνταξη, ο εκτελέσιμος κώδικας περιλαμβάνει τις εξής δομές δεδομένων:
\vspace{1.5em}
\begin{itemize}
    \item \textbf{\textlatin{Vertex,}} ώστε να αναπαραστήσει ένα σημείο στο επίπεδο με συντεταγμένες $x$ και $y$
    \item \textbf{\textlatin{Line}} για να αναπαραστήσει μια γραμμή με τις παραμέτρους $a,b,c$ και της εξίσωσης $ax+by+c=0$
    \item \textbf{\textlatin{Colour}} για να αναπαραστήσει ένα χρώμα με τις συνιστώσες $r,g,b$.
\end{itemize} 
\vspace{3em}
Οι κύριες συναρτήσεις που ορίστηκαν στον κώδικα αναγράφονται στον παρακάτω πίνακα. 
\vspace{3em}
\begin{center}
    \begin{longtable}{p{5cm}|p{6cm}} 
        \textbf{Συναρτήσεις} & \textbf{Ερμηνεία} \\ \hline \hline
        \textlatin{\lstinline[language=C++]!setPixel!} & Ορισμός ενός \textlatin{pixel} για $(x,y)$ με καθορισμένο χρώμα \\ \hline
        \textlatin{\lstinline[language=C++]!drawLine!} & Σχεδίαση γραμμής από $(x1,y1$ σε $(x2,y2)$ με το καθορισμένο χρώμα \\ \hline
        \textlatin{\lstinline[language=C++]!drawPolygon!} & Σχεδίαση πολυγώνου \\ \hline
        \textlatin{\lstinline[language=C++]!isConvex!} & 'Ελεγχος κυρτότητας \\ \hline
        \textlatin{\lstinline[language=C++]!convex1!}  & Υλοποίηση \textlatin{scanline} και γέμισμα \\ \hline
        \textlatin{\lstinline[language=C++]!display!} & Απεικόνιση των γραφικών. \\ \hline
        \textlatin{\lstinline[language=C++]!reshape!} & Ενημέρωση παραμέτρων του παραθύρου \\
        \hline
        \textlatin{\lstinline[language=C++]!glViewPort!} & Προσαρμογή περιοχής απεικόνισης \\ \hline
        \textlatin{\lstinline[language=C++]!keyboard!} & Καθορισμός προγράμματος βάση χρήστη \\
    \caption{Πίνακας Συναρτήσεων}
    \end{longtable}
\end{center}

\subsection{Εκτελέσιμος Κώδικας}

Ο κώδικας υποθέτει ότι το πολύγωνο ορίζεται από το χρήστη με τη σειρά των κλικ του ποντικιού πάνω στην οθόνη. Αυτό σημαίνει ότι το σημείο που ορίζεται κάθε φορά ενώνεται με ευθεία γραμμή με το τελευταίο σημείο. Λόγω του πεπερασμένου αριθμού των ακμών του πολυγώνου, η σχεδίασή του ολοκληρώνεται όταν δεν υπάρχει άλλο ενδεχόμενο σημείο εισαγωγής από το χρήστη που θα καθιστά το πολύγωνο κυρτό. Εναλλακτικά, η σχεδίαση ολοκληρώνεται όταν ο χρήστης πατήσει το πλήκτρο \textlatin{ESCAPE (ESC)}. Σε περίπτωση που ο χρήστης ορίσει με το ποντίκι σημεία που καθορίζουν το πολύγωνο μη κυρτό, ο έλεγχος κυρτότητας εξασφαλίζει την αποτελεσματικότητα του προγράμματος καθώς δεν θα σχεδιαστεί, και φυσικά δεν θα γεμίσει τα εσωτερικά εικονοστοιχεία του πολυγώνου. 
 \par
 Παρακάτω επισημαίνονται σημαντικά κομμάτια του κώδικα που εξασφαλίζουν την ομαλή και αποτελεσματική υλοποίηση σε \textlatin{OpenGL/C++}
 
\selectlanguage{english}
\begin{enumerate}
    \item \textbf{"std::vector<Vertex> vertices"}: Είναι ένα παγκόσμιο διάνυσμα που αποθηκεύει τις κορυφές του πολυγώνου που σχεδιάζει ο χρήστης.
    \item \textbf{"std::vector<Vertex> convexVertices"}: Είναι ένα διάνυσμα που χρησιμοποιείται για να αποθηκεύσει τις κορυφές του κυρτού πολυγώνου.
    \item "\textbf{void setPixel(float x, float y, const Colour\& colour)"}: Αυτή η συνάρτηση ορίζει το χρώμα ενός pixel στη θέση $(x, y)$ χρησιμοποιώντας τη δομή \emph{Colour} που έχει οριστεί.
    \item \textbf{"void drawLine(float x1, float y1, float x2, float y2, const Colour\& colour)"}: Αυτή η συνάρτηση σχεδιάζει μια γραμμή μεταξύ δύο σημείων $(x1, y1)$ και $(x2, y2)$ χρησιμοποιώντας τη δομή \emph{Colour} που έχει οριστεί.
    \item \textbf{"void drawPolygon(const std::vector<Vertex>\&polygon, const Colour\& colour)"}: Αυτή η συνάρτηση σχεδιάζει ένα πολύγωνο συνδέοντας τις κορυφές που αποθηκεύονται στο διάνυσμα \underline{polygon} χρησιμοποιώντας τη δομή \emph{Colour} που έχει οριστεί.
    \item \textbf{"bool isConvex(const std::vector<Vertex>\& polygon)"}: Αυτή η συνάρτηση ελέγχει εάν ένα πολύγωνο, που αναπαρίσταται από το διάνυσμα \underline{polygon} είναι κυρτό ή όχι. Πραγματοποιεί υπολογισμούς διανυσματικού γινομένου για να προσδιορίσει τον προσανατολισμό των ακμών του πολυγώνου.
    \item \textbf{"void convex1(const std::vector<Vertex>\& polygon, const Colour\& c)"}: Αυτή η συνάρτηση γεμίζει ένα κυρτό πολύγωνο, που αναπαρίσταται από το διάνυσμα polygon, χρησιμοποιώντας τον αλγόριθμο \emph{Scanline}. Υπολογίζει τις γραμμές και τις αρχικές εκτιμήσεις για κάθε κορυφή, καθορίζει το περίγραμμα που περικλείει το πολύγωνο και γεμίζει τα εσωτερικά pixels.
    \item \textbf{"void display()"}: Αυτή η συνάρτηση εμφανίζει το γραφικό παράθυρο και καλείται από τη βιβλιοθήκη OpenGL για να ανανεώνει την εικόνα στην οθόνη.
\end{enumerate}
\par
\clearpage


